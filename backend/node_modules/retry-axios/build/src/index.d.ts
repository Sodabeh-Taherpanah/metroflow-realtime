import { type AxiosError, type AxiosInstance, type AxiosRequestConfig } from 'axios';
/**
 * Configuration for the Axios `request` method.
 */
export interface RetryConfig {
    /**
     * The number of times to retry the request.  Defaults to 3.
     */
    retry?: number;
    /**
     * The number of retries already attempted.
     */
    currentRetryAttempt?: number;
    /**
     * The number of retries remaining before giving up.
     * Calculated as: retry - currentRetryAttempt
     */
    retriesRemaining?: number;
    /**
     * The delay in milliseconds used for retry backoff. Defaults to 100.
     * - For 'static' backoff: Fixed delay between retries
     * - For 'exponential' backoff: Base multiplier for exponential calculation
     * - For 'linear' backoff: Ignored (uses attempt * 1000)
     */
    retryDelay?: number;
    /**
     * The HTTP Methods that will be automatically retried.
     * Defaults to ['GET','PUT','HEAD','OPTIONS','DELETE']
     */
    httpMethodsToRetry?: string[];
    /**
     * The HTTP response status codes that will automatically be retried.
     * Defaults to: [[100, 199], [429, 429], [500, 599]]
     */
    statusCodesToRetry?: number[][];
    /**
     * Function to invoke when error occurred.
     */
    onError?: (error: AxiosError) => void | Promise<void>;
    /**
     * Function to invoke when a retry attempt is made.
     * The retry will wait for the returned promise to resolve before proceeding.
     * If the promise rejects, the retry will be aborted and the rejection will be propagated.
     */
    onRetryAttempt?: (error: AxiosError) => Promise<void>;
    /**
     * Function to invoke which determines if you should retry.
     * This is called after checking the retry count limit but before other default checks.
     * Return true to retry, false to stop retrying.
     * If not provided, uses the default retry logic based on status codes and HTTP methods.
     */
    shouldRetry?: (error: AxiosError) => boolean;
    /**
     * Backoff Type; 'linear', 'static' or 'exponential'.
     */
    backoffType?: 'linear' | 'static' | 'exponential';
    /**
     * Jitter strategy for exponential backoff. Defaults to 'none'.
     * - 'none': No jitter (default)
     * - 'full': Random delay between 0 and calculated exponential backoff
     * - 'equal': Half fixed delay, half random
     *
     * Jitter helps prevent the "thundering herd" problem where many clients
     * retry at the same time. Only applies when backoffType is 'exponential'.
     */
    jitter?: 'none' | 'full' | 'equal';
    /**
     * Whether to check for 'Retry-After' header in response and use value as delay. Defaults to true.
     */
    checkRetryAfter?: boolean;
    /**
     * Max permitted Retry-After value (in ms) - rejects if greater. Defaults to 5 mins.
     */
    maxRetryAfter?: number;
    /**
     * Ceiling for calculated delay (in ms) - delay will not exceed this value.
     */
    maxRetryDelay?: number;
    /**
     * Array of all errors encountered during retry attempts.
     * Populated automatically when retries are performed.
     * The first element is the initial error, subsequent elements are retry errors.
     */
    errors?: AxiosError[];
}
export type RaxConfig = {
    raxConfig: RetryConfig;
} & AxiosRequestConfig;
/**
 * Attach the interceptor to the Axios instance.
 * @param instance The optional Axios instance on which to attach the
 * interceptor.
 * @returns The id of the interceptor attached to the axios instance.
 */
export declare function attach(instance?: AxiosInstance): number;
/**
 * Eject the Axios interceptor that is providing retry capabilities.
 * @param interceptorId The interceptorId provided in the config.
 * @param instance The axios instance using this interceptor.
 */
export declare function detach(interceptorId: number, instance?: AxiosInstance): void;
/**
 * Determine based on config if we should retry the request.
 * @param err The AxiosError passed to the interceptor.
 */
export declare function shouldRetryRequest(error: AxiosError): boolean;
/**
 * Acquire the raxConfig object from an AxiosError if available.
 * @param err The Axios error with a config object.
 */
export declare function getConfig(error: AxiosError): RetryConfig | undefined;
declare module 'axios' {
    interface AxiosRequestConfig {
        raxConfig?: RetryConfig;
    }
}
